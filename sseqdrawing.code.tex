%%
%% Package: spectralsequences v1.0.0-dev
%% Author: Hood Chatham
%% Email: hood@mit.edu
%% Date: 2017-06-21
%% License: Latex Project Public License
%%
%% File: sseqdrawing.code.tex
%%
%%    Defines the macros that draw the features of the spectral sequence (at least, those that aren't drawn by tikz).
%%    Everything here has to be super optimized, because like 90% of the execution time is in these functions.
%%    In particular, tikz is a horrible performance hole that must be avoided at all costs. For example, the code
%%    the code to produce the axis ticks used to use the tikz \node command, and in the file example_KF3n.tex drawing
%%    the axes ticks was taking about 1/3 of the compile time (a little under 1s out of a 3.2)
%%

\def\sseq@resettransform{\pgftransformreset}%\pgfsetxvec{\pgfpointxy{1cm}{0cm}}\pgfsetyvec{\pgfpointxy{0cm}{1cm}}}
\def\sseq@resetnontranslations{\pgftransformresetnontranslations}%\pgfsetxvec{\pgfpointxy{1cm}{0cm}}\pgfsetyvec{\pgfpointxy{0cm}{1cm}}}


%%%
%%% Draw axes and clip
%%%
\def\sseq@handlexaxis{
    \ifsseq@drawxaxis
        \bgroup
        \ifsseq@borderxaxis\else
            \let\sseq@ymin\sseq@yaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawxaxis
        \ifsseq@drawxaxisticks
            \sseq@drawxticks
        \fi
        \egroup
    \fi
}
\def\sseq@handleyaxis{
    \ifsseq@drawyaxis
        \bgroup
        \ifsseq@borderyaxis\else
            \let\sseq@xmin\sseq@xaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawyaxis
        \ifsseq@drawyaxisticks
            \sseq@drawyticks
        \fi
        \egroup
    \fi
}
\def\sseq@drawxaxis{
    \bgroup
    \pgftransformshift{\pgfqpoint{\sseq@xaxis@end@extend}{-\sseq@xaxisgap}}
    \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
    \egroup
%
    \bgroup
    \pgftransformshift{\pgfqpoint{\dimexpr-\sseq@xaxis@start@extend-\sseq@yaxisgap\relax}{-\sseq@xaxisgap}}
    \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
    \egroup
    \pgfusepath{stroke}
}
\def\sseq@drawyaxis{
    \bgroup
    \pgftransformshift{\pgfqpoint{-\sseq@yaxisgap}{\sseq@yaxis@end@extend}}
    \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
    \egroup
%
    \bgroup
    \pgftransformshift{\pgfqpoint{-\sseq@yaxisgap}{\dimexpr-\sseq@xaxisgap-\sseq@yaxis@start@extend\relax}}
    \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
    \egroup
    \pgfusepath{stroke}%
}
\ExplSyntaxOn
\def\sseq@intdivceiling#1#2{%
    \ifnum#1>\z@ % \int_div_truncate:nn rounds towards 0. We want \int_div_ceiling
        \int_div_truncate:nn{#1+#2-1}{#2} % if positive, use ceil(p/q)=floor((p+q-1)/q) for p,q integers
    \else
        \int_div_truncate:nn{#1}{#2} % if we are negative, towards 0 is ceiling
    \fi
}
\def\sseq@intdivfloor#1#2{%
    \ifnum#1<\z@ % \int_div_truncate:nn rounds towards 0. We want \int_div_floor
        \int_div_truncate:nn{#1-#2+1}{#2} % if we are negative, use floor(p/q) = ceil(p-q+1/q) for p,q integers
    \else
        \int_div_truncate:nn{#1}{#2} % if positive, towards 0 is floor
    \fi
}
\ExplSyntaxOff

\def\sseq@drawxticks{%
    \sseq@tempy=\sseq@ymin\relax
    \sseq@tempx=\numexpr % min
        \sseq@intdivceiling{\sseq@xmin}{\sseq@xtickstep} * \sseq@xtickstep
        -
        \sseq@intdivceiling{\sseq@xtickstepoffset}{\sseq@xtickstep} * \sseq@xtickstep + \sseq@xtickstepoffset
    \relax
    \ifnum\sseq@tempx<\sseq@xmin\relax
        \advance\sseq@tempx\sseq@xtickstep\relax
    \fi
    \sseq@tempxb=\numexpr\sseq@xmax+1\relax % max
    \loop
        \bgroup
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfqpointxy{\the\numexpr\sseq@tempx+\sseq@xoffset\relax}{\the\numexpr\sseq@tempy+\sseq@yoffset\relax}}}%
        \sseq@resetnontranslations
        \sseq@globaldetonetransform
        \pgftransformshift{\pgfqpoint{0pt}{\dimexpr-\sseq@xlabelgap-\sseq@xaxisgap\relax}}%
        \sseq@resetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \sseq@xtickstyle
        \tikz@options
        \pgftext{\hbox{$\sseq@xtickfn{\the\sseq@tempx}$}}%
        \egroup
        \advance\sseq@tempx\sseq@xtickstep\relax
    \ifnum\sseq@tempx<\sseq@tempxb\repeat
}
\def\sseq@drawyticks{%
    \sseq@tempx=\sseq@xmin\relax
    \sseq@tempy=\numexpr % min
        \sseq@intdivceiling{\sseq@ymin}{\sseq@ytickstep} * \sseq@ytickstep
        -
        \sseq@intdivceiling{\sseq@ytickstepoffset}{\sseq@ytickstep} * \sseq@ytickstep + \sseq@ytickstepoffset
    \relax
    \ifnum\sseq@tempy<\sseq@ymin\relax
        \advance\sseq@tempy\sseq@ytickstep\relax
    \fi
    \sseq@tempyb=\numexpr\sseq@ymax+1\relax % max
    \loop
        \bgroup
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfqpointxy{\the\numexpr\sseq@tempx+\sseq@xoffset}{\the\numexpr\sseq@tempy+\sseq@yoffset}}}%
        \sseq@resetnontranslations
        \sseq@globaldetonetransform
        \pgftransformshift{\pgfqpoint{\dimexpr-\sseq@ylabelgap-\sseq@yaxisgap\relax}{0pt}}%
        \sseq@resetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \sseq@ytickstyle
        \tikz@options
        \pgftext{\hbox{$\sseq@ytickfn{\the\sseq@tempy}$}}%
        \egroup
        \advance\sseq@tempy\sseq@ytickstep\relax
    \ifnum\sseq@tempy<\sseq@tempyb\repeat
}
\def\sseq@setupclip{
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \ifsseq@clip
        \ifx\sseq@customclip\pgfutil@empty
            \bgroup
            %\sseq@resettransform
            %\sseq@globaldetonetransform
            \ifsseq@borderyaxis
                \def\xmin{\pgftransformshift{\pgfqpoint{\dimexpr-\sseq@yaxisgap+\sseq@yclip@axisgap\relax}{0pt}}}
            \else
                \def\xmin{\pgftransformshift{\pgfqpoint{\dimexpr-\sseq@xaxis@start@extend-\sseq@clip@padding@left\relax}{0pt}}}
            \fi
            \ifsseq@borderxaxis
                \def\ymin{\pgftransformshift{\pgfqpoint{0pt}{\dimexpr-\sseq@xaxisgap+\sseq@xclip@axisgap\relax}}}
            \else
                \def\ymin{\pgftransformshift{\pgfqpoint{0pt}{\dimexpr-\sseq@yaxis@start@extend-\sseq@clip@padding@bottom\relax}}}
            \fi
            \def\xmax{\pgftransformshift{\pgfqpoint{\dimexpr\sseq@xaxis@end@extend+\sseq@clip@padding@right\relax}{0pt}}}
            \def\ymax{\pgftransformshift{\pgfqpoint{0pt}{\dimexpr\sseq@yaxis@end@extend+\sseq@clip@padding@top\relax}}}
            \bgroup
            \xmin\ymin%\sseq@globalscaletransform
            \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmin\ymax%\sseq@globalscaletransform
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmax\ymax%\sseq@globalscaletransform
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
            \egroup
            \bgroup
            \xmax\ymin%\sseq@globalscaletransform
            \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
            \egroup
            \egroup
            \pgfpathclose
            \pgfgetpath\sseq@theclippath % This stores the clipping so I can apply it later
            \pgfusepath{discard}% This has to be after the egroup or else the clipping gets screwed up
%
            \bgroup
                %\sseq@globalscaletransform
                \pgfpathmoveto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmin+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymax+\sseq@yoffset\relax}}
                \pgfpathlineto{\pgfqpointxy{\numexpr\sseq@xmax+\sseq@xoffset\relax}{\numexpr\sseq@ymin+\sseq@yoffset\relax}}
                \pgfpathclose
            \egroup
            \pgfgetpath\sseq@therangepath % Only for deciding whether to draw "tricky edges"
            \pgfusepath{discard}
        \else
            \def\sseq@temp{\path[name path=temp]}
            \@xptwo\sseq@temp\@xp\@gobble\sseq@customclip
            \pgfgetpath\sseq@theclippath
            \let\sseq@theclippath\tikz@intersect@path@name@temp
        \fi
    \else
        \let\sseq@theclippath\relax
    \fi
}
\def\sseq@useclip{\ifx\sseq@theclippath\relax\else\pgfsetpath\sseq@theclippath\pgfusepath{clip}\fi}
\def\sseq@grid@chess{
 \bgroup
 \pgfscope
 \sseq@useclip
 \pgf@process{\pgfqpointxy{\sseq@xgridstep}{0}}
 \pgf@xa=\pgf@x
 \pgf@process{\pgfqpointxy{0}{\sseq@ygridstep}}
 \pgf@ya=\pgf@y
 \pgfsetxvec{\pgfpoint{1cm}{0cm}}
 \pgfsetyvec{\pgfpoint{0cm}{1cm}}
 %\pgfmathparse{\sseq@xscalecm/\pgf@xa}
 \pgftransformxscale{\sseq@xscale}
 \pgftransformyscale{\sseq@yscale}
 %\pgfmathparse{\sseq@yscalecm/\pgf@ya}
 \pgflowlevelsynccm
 \pgfsetlinewidth{1cm}
 \pgfsetdash{{1cm}{1cm}}{0cm}
 \pgfsetcolor{\sseq@gridcolor}
 \sseq@tempx=\numexpr\sseq@intdivceiling{\sseq@xmin}{2*\sseq@xscale}*2*\sseq@xscale\relax
 \sseq@tempy=\numexpr\sseq@intdivceiling{\sseq@ymin}{2*\sseq@xscale}*2*\sseq@xscale\relax
 \sseq@tempxb=\sseq@xmax\relax
 \sseq@tempyb=\sseq@ymax\relax
% \ifodd\sseq@xmin
%    \pgftransformshift{\pgfqpoint{-1cm}{0pt}}
%    \advance\sseq@tempxb\@ne
% \fi
% \ifodd\sseq@ymin
%    \pgftransformshift{\pgfqpoint{0pt}{-1cm}}
%    \advance\sseq@tempyb\@ne
% \fi
% \sseq@xoffset=\numexpr\sseq@intdivfloor{\sseq@xoffset}{2}*2\relax
% \sseq@yoffset=\numexpr\sseq@intdivfloor{\sseq@yoffset}{2}*2\relax
 \pgfpathgrid[stepx= 2cm,stepy=2cm]
    { \pgfpointxy { (-0.5+ \the\sseq@tempx +\sseq@xoffset) } { ( -0.5 + \the\sseq@tempy +\sseq@yoffset )} }
    { \pgfpointxy { (\the\sseq@tempxb +\sseq@xoffset ) }{ (\the\sseq@tempyb + \sseq@yoffset ) } }
 \pgfusepath{stroke}
 \endpgfscope
 \egroup
}
\def\sseq@grid@crossword{
 \bgroup
 \pgfscope
 \sseq@useclip
 \pgfsetcolor{\sseq@gridcolor}
 \pgfsetlinewidth{\the\sseq@gridstrokethickness}

 \pgf@process{\pgfqpointxy{1}{0}}
 \pgf@xa=\pgf@x
 \pgf@process{\pgfqpointxy{0}{1}}
 \pgf@ya=\pgf@y
 \sseq@tempx=\numexpr \dimexpr(\sseq@yaxisgap-\sseq@yclip@axisgap)\relax/\pgf@xa\relax
 \sseq@tempy=\numexpr \dimexpr(\sseq@xaxisgap-\sseq@xclip@axisgap)\relax/\pgf@ya\relax
 \sseq@tempxb=\numexpr \dimexpr\sseq@xaxis@end@extend\relax/\pgf@xa+\sseq@xgridstep/2\relax
 \sseq@tempyb=\numexpr \dimexpr\sseq@yaxis@end@extend\relax/\pgf@ya+\sseq@ygridstep/2\relax

 \pgf@process{\pgfqpointxy{\sseq@xgridstep}{0}}
 \pgf@xa=\pgf@x
 \pgf@process{\pgfqpointxy{0}{\sseq@ygridstep}}
 \pgf@ya=\pgf@y
 \pgftransformshift{\pgfpointxy{-\sseq@xgridstep/2}{-\sseq@ygridstep/2}}

 \pgfpathgrid[stepx=\pgf@xa,stepy=\pgf@ya]
    { \pgfqpointxy
        { \numexpr\sseq@xmin - \sseq@tempx +\sseq@xoffset\relax }
        { \numexpr\sseq@ymin - \sseq@tempy +\sseq@yoffset \relax} }
    { \pgfpointxy
        { \sseq@xmax + \sseq@tempxb - 0.01 +\sseq@xoffset }
        { \sseq@ymax + \sseq@tempyb - 0.01 +\sseq@yoffset }
    }
 \pgfusepath{stroke}
 \endpgfscope
 \egroup
}
\def\sseq@grid@go{
 \bgroup
 \pgfscope
 \sseq@useclip
 \pgfsetcolor{\sseq@gridcolor}
 \pgfsetlinewidth{\the\sseq@gridstrokethickness}
%
 \pgf@process{\pgfqpointxy{1}{0}}
 \pgf@xa=\pgf@x
 \pgf@process{\pgfqpointxy{0}{1}}
 \pgf@ya=\pgf@y
 \sseq@tempx=\numexpr \dimexpr(\sseq@yaxisgap-\sseq@yclip@axisgap)\relax/\pgf@xa+1\relax
 \sseq@tempy=\numexpr \dimexpr(\sseq@xaxisgap-\sseq@xclip@axisgap)\relax/\pgf@ya+1\relax
%
 \pgf@process{\pgfqpointxy{\sseq@xgridstep}{0}}
 \pgf@xb=\pgf@x
 \pgf@process{\pgfqpointxy{0}{\sseq@ygridstep}}
 \pgf@yb=\pgf@y
%
 \sseq@tempdimen=\dimexpr\sseq@xaxis@end@extend\relax
 \ifdim\sseq@tempdimen<\pgf@xb
    \pgfmathparse{\sseq@tempdimen/\pgf@xa}
    \let\sseq@tempa\pgfmathresult
 \else
    \def\sseq@tempa{\sseq@xgridstep}
 \fi
%
 \sseq@tempdimen=\dimexpr\sseq@yaxis@end@extend\relax
 \ifdim\sseq@tempdimen<\pgf@yb
     \pgfmathparse{\sseq@tempdimen/\pgf@ya}
      \let\sseq@tempb\pgfmathresult
 \else
    \def\sseq@tempb{\sseq@ygridstep}
 \fi
%
 \pgfpathgrid[stepx=\pgf@xb,stepy=\pgf@yb]
    { \pgfqpointxy
        { \numexpr\sseq@xmin - \sseq@tempx +\sseq@xoffset\relax }
        { \numexpr\sseq@ymin - \sseq@tempy +\sseq@yoffset\relax} }
    { \pgfpointxy
        { \sseq@xmax + \sseq@tempa - 0.01 +\sseq@xoffset  }
        { \sseq@ymax + \sseq@tempb - 0.01 +\sseq@yoffset  }
    }
 \pgfusepath{stroke}
 \endpgfscope
 \egroup
}
\def\sseq@grid@none{}
\def\sseq@grid@dots{
 \bgroup
 \pgfscope
 \pgfgettransform\sseq@savetransform
 %\sseq@resettransform
 %\sseq@globalscaletransform
 \pgfgettransformentries{\sseq@a}{\sseq@b}{\sseq@c}{\sseq@d}{\sseq@u}{\sseq@v}
 \pgfsettransform\sseq@savetransform
 \sseq@useclip
 \pgftransformshift{\pgfqpoint{-1.5cm}{-0.5cm}}
 \pgfsetdash{{1pt}{\sseq@a*1cm-1pt}}{0.5cm+.5pt}
 \pgfsetlinewidth{1pt}
 \sseq@tempy=\sseq@ymin\relax
 \advance\sseq@tempy\m@ne
 \loop
 \advance\sseq@tempy\@ne
 \pgfpathmoveto{\pgfpointxy{\sseq@xmin + 0.5/\sseq@a}{\the\sseq@tempy}}
 \pgfpathlineto{\pgfpointxy{\sseq@xmax + 1.01 }{\the\sseq@tempy}}
 \ifnum\sseq@tempy<\sseq@ymax\repeat
 %\pgfpathgrid[stepx=1cm,stepy=1cm]{\pgfpoint{-0.5cm}{-0.5cm}}{\pgfpoint{\xmax cm-0.5cm}{\ymax cm-0.5cm}}
 \pgfusepath{stroke}
 \endpgfscope
 \egroup
}
%%%
%%% Draw Classes
%%%
%%% Class offsets
\sseqnewclasspattern{standard}{
    (0,0);
    (-0.13,0)(0.13,0);
    (-0.2,0)(0,0)(0.2,0);
    (-0.13,-0.13)(0.13,-0.13)(-0.13,0.13)(0.13,0.13);
    (-0.16,-0.16)(0.16,-0.16)(-0.16,0.16)(0.16,0.16)(0,0);
    (-0.13,-0.2)(-0.13,0)(-0.13,0.2)(0.13,-0.2)(0.13,0)(0.13,0.2);
}

\sseqnewclasspattern{linear}{
    (0,0);
    (-0.13,0)(0.13,0);
    (-0.2,0)(0,0)(0.2,0);
    (-0.3,0)(-0.1,0)(0.1,0)(0.3,0);
    (-0.4,0)(-0.2,0)(0,0)(0.2,0)(0.4,0);
    (-0.5,0)(-0.3,0)(-0.1,0)(0.1,0)(0.3,0)(0.5,0);
}
\def\sseq@offset#1#2{
    \sseq@eval{\@nx\pgftransformshift{
        \@nx\pgfqpointxy
            { \csname sseq@\sseq@classpattern xoffset#1/#2\endcsname }
            { \csname sseq@\sseq@classpattern yoffset#1/#2\endcsname }
    }}
}
\def\sseq@class@getparts#1(#2,#3,#4)[#5].{
    \sseq@seterrorannotation@drawing{#1}{#2}{#3}{#4}{#5}
    \def\sseq@thisclassname{class.(#2,#3,#4)}
    \def\sseq@thisnodename{sseq{#2,#3,#4}}
    \def\sseq@thispos{(#2,#3)}
    \def\sseq@thisposnum{#4}
    \def\sseq@thisclassnum{#5}
}

\def\sseqtooltip#1#2{%
    \edef\temp{\detokenize\@xpthree{#2}}%
    \edef\temp{\@xp\sseqtooltip@replaceslashes\@xp{\temp}}%
    \sseq@eval{\@nx\pdftooltip{\unexpanded{#1}}{\temp}}%
}
\bgroup\lccode`\!=`\\\lowercase{\egroup
\def\sseqtooltip@replaceslashes#1{\sseqtooltip@replaceslashes@#1!\sseq@nil}
\def\sseqtooltip@replaceslashes@#1!#2{%
    #1%
    \ifx\sseq@nil#2\@xp\@gobble\else
        \@nx\@nx\@nx\textbackslash
        \@xp\sseqtooltip@replaceslashes@
    \fi#2%
}
}

% #1 -- the name of the node object
% Someday I should document this horrible mess of code here
\newif\ifsseq@permanentcycle
\def\sseq@class@drawnode#1{%
    \begingroup
    \sseq@class@getparts#1.
    \sseq@tempx=\sseq@obj{\sseq@thisclassname.x}\relax
    \sseq@tempy=\sseq@obj{\sseq@thisclassname.y}\relax
    \sseq@needstikzfalse
    \sseq@options@firstpassmode
        \sseq@thesseqstyle
        \sseq@theclassstyle
        \ifnum\sseq@obj{#1.page}=\sseq@infinitycount
            \sseq@thepermanentcyclestyle
        \else
            \sseq@thetransientcyclestyle
            \ifsseq@thispage
                \sseq@thethispagecyclestyle
            \fi
        \fi
        \the\sseq@scope@toks
        \sseq@obj{#1.needstikz}
%
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \pgfscope
        \let\tikz@options\pgfutil@empty
        \let\tikz@alias=\pgfutil@empty
        \def\pgfkeysdefaultpath{/sseqpages/class/}
        \sseq@options@secondpassmode
            \sseq@thesseqstyle
            \sseq@theclassstyle
            \ifnum\sseq@obj{#1.page}=\sseq@infinitycount
                \sseq@permanentcycletrue % This is to communicate with family style code...
                \sseq@thepermanentcyclestyle
            \else
                \sseq@permanentcyclefalse
                \sseq@thetransientcyclestyle
                \ifsseq@thispage
                    \sseq@thethispagecyclestyle
                \fi
            \fi
            \the\sseq@scope@toks
            \sseq@obj{#1.options}%
            \sseq@collections@class@hook
        \pgftransformshift{\pgfqpointxy{\numexpr\sseq@tempx +\sseq@xoffset-\sseq@x\relax}{\numexpr\sseq@tempy + \sseq@yoffset-\sseq@y\relax}}
        \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@obj@ifdef{#1.offset}{\sseq@obj{#1.offset}}{%
            \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}%
        }%
        \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\ifsseq@rotatelabels\sseq@globalrotatetransform\fi\fi
        \tikz@options
        \ifsseq@needstikz
            \let\sseq@mode\tikz@mode
            \tikzset{every text node part/.code/.expand once={\sseq@globalrotatetransform\sseq@obj{#1.nodetext.options}}}%
            \sseq@eval{%
                \@nx\node[/utils/exec={\let\@nx\tikz@mode\@nx\sseq@mode},
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote
                ] (\sseq@thisnodename) {\unexpanded\@xpthree{\sseq@obj{#1.nodetext}}}
                [every text node part/.code={}];
            }%
        \else
            \tikz@node@textfont
            \edef\sseq@classnodetextoptions{\@xptwo\@nx\sseq@obj{#1.nodetext.options}}
            \edef\sseq@classnodetext{\@xptwo\@nx\sseq@obj{#1.nodetext}}
            \sseq@setnodetext{\sseq@classnodetext}{\sseq@classnodetextoptions}
            \let\tikz@fig@name\sseq@thisnodename
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
        \fi
        \sseq@obj{#1.labelnodes}
        \sseq@obj@ifdef{#1.tooltip}{
            \pgfpointanchor{\sseq@thisnodename}{west}
            \pgf@xa=\pgf@x
            \pgfpointanchor{\sseq@thisnodename}{south}
            \pgf@ya=\pgf@y
%
            \pgf@process{\pgfpointdiff{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{west}}}{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{east}}}}
            \pgf@xb=\pgf@x
            \pgf@process{\pgfpointdiff{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{south}}}{\pgfpointtransformed{\pgfpointanchor{\sseq@thisnodename}{north}}}}
            \pgf@yb=\pgf@y
%
            \setbox\tikz@tempbox=\hbox{
                \pgfinterruptpicture
                \sseqtooltip{\rule{\pgf@xb}{0pt}\rule{0pt}{\pgf@yb}}{\sseq@obj{#1.tooltip}}
                \endpgfinterruptpicture
            }
            {%
                \pgftransformshift{\pgfqpoint{\pgf@xa}{\pgf@ya}}%
                \pgfapproximatenonlineartransformation%
                \pgfqboxsynced{\tikz@tempbox}%
            }%
        }{}
        \endpgfscope
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfqpointxy{\numexpr\sseq@tempx+\sseq@xoffset-\sseq@x\relax}{\numexpr\sseq@tempy+\sseq@yoffset-\sseq@y\relax}}}%
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
        \pgfcoordinate{\sseq@thisnodename}{\pgfpointorigin}%
    \fi
    \endgroup
}

% #1 -- label text
% #2 -- options
\def\sseq@setnodetext#1#2{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        #2
        \tikzset{every text node part/.try}%
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          #1%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}
\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    %\iftikz@mode@clip \sseq@error@internal{Clip shouldn't happen here, but this error should be caught earlier}{}\fi %
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \sseq@eval{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}

%%% Labels

% #1 -- label text
% #2 -- options
\def\sseq@drawlabel#1#2{
    \bgroup\pgfscope
    \def\tikz@mode{}
    \let\sseq@tikz@transform@save\tikz@transform
    \pgfkeyssetvalue{/pgf/inner xsep}{2pt}
    \pgfkeyssetvalue{/pgf/inner ysep}{2pt}
    \def\tikz@shape{rectangle}
    \let\tikz@transform\empty % The next line was set up to fix the classlabelstyle glitch
    \sseq@options@secondpassmode
    \sseq@thesseqstyle\sseq@thelabelstyle\sseq@theclasslabelstyle#2
    \tikz@options
    \pgftransformreset
    \pgftransformshift{\tikz@node@at}
    \tikz@lib@pos@call
    \tikz@transform
    \tikz@mode
    \let\tikz@transform\sseq@tikz@transform@save
    \sseq@setnodetext{\sseq@labeltextfn{#1}}{}
    \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{label}{\sseq@drawnode}%
    \ifsseq@pin
        \def\sseq@pinoptions{}
        \let\tikz@options\empty
        \let\tikz@mode\empty
        \sseq@thepinstyle
        #2
        \sseq@pinoptions
        \tikz@options
        \tikz@mode
        \sseq@drawedge@findsourcetarget{\tikz@fig@name}{}{label}{}
        \pgfpathmoveto{\sseq@sourcecoord}%
        \pgfpathlineto{\sseq@targetcoord}%
        \sseq@eval{\noexpand\pgfusepath{%
            draw
            \iftikz@mode@fill fill,\fi
            \iftikz@mode@draw draw,\fi
        }}%
    \fi
    \endpgfscope\egroup
}


%%%
%%% Drawing edges
%%%
\def\sseq@ifinrange(#1){\sseq@ifinrange@#1,\sseq@nil}
\def\sseq@ifinrange@#1,#2,#3\sseq@nil{%
    \sseq@tempx=#1\relax\sseq@tempy=#2\relax
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
    \sseq@outofrangefalse
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \@xp\pgfutil@secondoftwo
    \else
        \@xp\pgfutil@firstoftwo
    \fi
}

% #1 -- source node
% #2 -- source anchor
% #3 -- target node
% #4 -- target anchor
% Calculate actual start and end of the edge (node borders), return the results stored in \sseq@sourcecoord, \sseq@targetcoord
\def\sseq@drawedge@findsourcetarget#1#2#3#4{
    \edef\sseq@edgesourceanchor{#2}
    \edef\sseq@edgetargetanchor{#4}
    \let\tempaf\pgfutil@empty
    \ifx\sseq@edgesourceanchor\pgfutil@empty % Check that the source doesn't have a specified anchor
        \def\tempa{\pgfpointanchor{#1}{center}}% if so, start by taking the center of that coordinate
    \else
        \edef\tempa{\@nx\pgfpointanchor{#1}{\sseq@edgesourceanchor}} % If it has an anchor, use that
        \let\tempaf\tempa
    \fi
    \ifx\sseq@edgetargetanchor\pgfutil@empty % check that the target doesn't have a specified anchor
        \def\tempb{\pgfpointshapeborder{#3}{\tempa}}% if so, our end point is the point on the boundary of node b that is in the direction of our initial start coordinate
    \else
        \edef\tempb{\@nx\pgfpointanchor{#3}{\sseq@edgetargetanchor}}% If it has a specified anchor, use that
    \fi
    \let\tempbf\tempb
    \ifx\tempaf\pgfutil@empty%
        \def\tempaf{\pgfpointshapeborder{#1}{\tempb}}%
    \fi
    \let\sseq@sourcecoord\tempaf
    \let\sseq@targetcoord\tempbf
}

\def\sseq@fullcoord@to@partialcoord(#1){\sseq@fullcoord@to@partialcoord@#1,\@nil}
\def\sseq@fullcoord@to@partialcoord@#1,#2,#3\@nil{{#1cm}{#2cm}}
% #1 -- source (full)
% #2 -- target (full)
% #3 -- which type of edge (either "structline" or "differential")
% #4 -- options
\def\sseq@drawedge(#1)(#2)#3#4{%
    \begingroup\pgfscope
    \def\sseq@edgetype{#3}
    \let\sseq@edgesourceanchor\pgfutil@empty
    \let\sseq@edgetargetanchor\pgfutil@empty
%
    \sseq@needstikzfalse
    \def\pgfkeysdefaultpath{/sseqpages/#3/}%
    \sseq@options@bothpassmode
    \sseq@thesseqstyle
    \sseq@theedgestyle\csname sseq@the#3style\endcsname\the\sseq@scope@toks
    #4%
    \csname sseq@collections@#3@hook\endcsname
    \pgftransformshift{\pgfqpointxy{-\the\sseq@x}{-\the\sseq@y}}%
    % puts results into \sseq@sourcecoord and \sseq@targetcoord
    \sseq@drawedge@findsourcetarget{sseq{#1}}{\sseq@edgesourceanchor}{sseq{#2}}{\sseq@edgetargetanchor}
%
    \tikz@options
    \tikz@mode
    \def\temparrowstartspec{}%
    \def\temparrowendspec{}%
    \pgfcoordinate{tempa}{\sseq@sourcecoord}%
    \pgfcoordinate{tempb}{\sseq@targetcoord}%
    \pgftransformreset
    \sseq@outofrangefalse
    \sseq@ifinrange(#1){}{
        \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}
        \sseq@outofrangetrue
    }%
    \sseq@ifinrange(#2){}{
        \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
        \sseq@outofrangetrue
    }
    \ifsseq@outofrange
        \sseq@handleoffpageedge{#1}{#2}%
    \fi
    \ifsseq@drawedge
        % TODO: should some sort of transformation manipulation be here? Maybe allow user to specify preference?
        % Don't draw dots on very short segments
        \pgfpointdiff{\sseq@targetcoord}{\sseq@sourcecoord}
        \pgfmathveclen{\pgf@x}{\pgf@y}%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \ifnum\pgfmathresult<10\relax%%17? % TODO: Fix this predicate
            \tikzset{every text node part/.append code={\pgfsetcolor{white}}}% I wonder why this is here...
            \ifx\temparrowstartspec\pgfutil@empty
            \else
                \def\temparrowstartspec{\pgfsetarrowsstart{}}%
            \fi
            \ifx\temparrowendspec\pgfutil@empty
            \else
                \def\temparrowendspec{\pgfsetarrowsend{}}%
            \fi
        \fi
        \ifsseq@needstikz
            \draw[/sseqpages,
                /utils/exec={\sseq@thesseqstyle\sseq@theedgestyle\csname sseq@the#3style\endcsname\the\sseq@scope@toks
                             \temparrowstartspec\temparrowendspec #4}%
            ]  (tempa) to (tempb);%
        \else
            \temparrowstartspec
            \temparrowendspec
            \pgfpathmoveto{\pgfpointanchor{tempa}{center}}%
            \pgfpathlineto{\pgfpointanchor{tempb}{center}}%
            \sseq@eval{\noexpand\pgfusepath{%
                \iftikz@mode@fill fill,\fi
                \iftikz@mode@draw draw,\fi
            }}%
        \fi
    \fi
    \sseq@breakpoint
    \endpgfscope\endgroup
}

% TODO: this macro is super expensive. Make it faster
\def\sseq@handleoffpageedge#1#2{
    \pgfpathmoveto{\sseq@sourcecoord}%
    \pgfpathlineto{\sseq@targetcoord}%
    \pgfgetpath\thispath
    \pgfusepath{discard}%
    \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}%
    \ifcase\pgfintersectionsolutions\relax
        % No intersections, but one or both endpoints may be out of range but still in clipping region due to scaling. Add ellipses as appropriate.
        \sseq@ifinrange(#1){% If the first endpoint is in range, the second must be out of range b/c sseq@outofrange is true.
            %\edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
        }{%
            \sseq@ifinrange(#2){}{\sseq@drawedge@handletrickyedge}% uh-oh, both ends are out of range
        }%
    \or
        \sseq@ifinrange(#1){% If the startpoint is in range, the intersection must be the end.
            \def\sseq@targetcoord{\pgfpointintersectionsolution{1}}
            \pgfcoordinate{tempb}{\sseq@targetcoord}
        }{%
            \sseq@ifinrange(#2){% If the startpoint is out of range and the endpoint is in range, the intersection must be the start
                \def\sseq@sourcecoord{\pgfpointintersectionsolution{1}}%
                \pgfcoordinate{tempa}{\sseq@sourcecoord}%
            }{\sseq@drawedge@handletrickyedge}% Uh-oh, both ends are out of range.
        }
    \or% an orphan
        \ifsseq@draworphanedges
            \sseq@drawedge@handleorphan
        \else
            \sseq@drawedgefalse % Don't draw "orphaned edges"
        \fi
    \else
        \sseq@error{clip-not-convex}%
        \sseq@breakfifi
    \fi
}

\def\sseq@drawedge@handletrickyedge{%
    \ifsseq@draworphanedges
        \pgfintersectionofpaths{\pgfsetpath\sseq@therangepath}{\pgfsetpath\thispath}%
        \ifnum\pgfintersectionsolutions=\z@
            \sseq@drawedgefalse % don't draw orphan edges that never intersect actual range
        \else% Now we have to make a line through tempa and tempb long enough so that it intersects the original clip area twice.
            \pgfmathanglebetweenpoints{\pgfpointanchor{tempa}{center}}{\pgfpointanchor{tempb}{center}}%
            \edef\tempangle{\pgfmathresult}
            \pgfpathmoveto{\pgfpointadd{\pgfpointanchor{tempa}{center}}{\pgfpointpolar{\tempangle}{100cm}}}% a really long line
            \pgfpathlineto{\pgfpointadd{\pgfpointanchor{tempa}{center}}{\pgfpointpolar{\tempangle}{-100cm}}}%
            \pgfgetpath\thispath
            \pgfusepath{discard}
            \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}
            \sseq@drawedge@handleorphan
        \fi
    \else
        \sseq@drawedgefalse
    \fi
}


\def\sseq@drawedge@handleorphan{%
    \def\sseq@sourcecoord{\pgfpointintersectionsolution{1}}%
    \def\sseq@targetcoord{\pgfpointintersectionsolution{2}}%
    \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@\sseq@edgetype @spec\endcsname}}%
    \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@\sseq@edgetype @spec\endcsname}}%
    \pgfcoordinate{tempa}{\sseq@sourcecoord}%
    \pgfcoordinate{tempb}{\sseq@targetcoord}%
}


%
% #1 -- first coordinate
% #2 -- second coordinate
% #3 -- uid
\def\sseq@circleclass@draw#1#2#3{
    \begingroup
        \pgfmathanglebetweenpoints{\pgfpointanchor{sseq{#2}}{center}}{\pgfpointanchor{sseq{#3}}{center}}
        \let\tempangle\pgfmathresult
        \let\tikz@lib@fit@scan@handle\sseq@fit@tikz@lib@fit@scan@handle % install fit modifications.
        \let\tikz@calc@anchor\sseq@fit@tikz@calc@anchor
        \sseq@tempiftrue
        \sseq@options@secondpassmode
        \node[
            rotate fit=\tempangle,
            /utils/exec={\sseq@thesseqstyle\sseq@thecircleclassstyle\the\sseq@scope@toks\sseq@savedoptioncode
                \sseq@obj{#1.options}
                \sseq@collections@circleclass@hook
                \sseq@obj{#1.fitnodes}
                \@xp\pgfkeysalso\@xp{\romannumeral0\sseq@obj{#1.tikzprimoptions}}
            }
        ] {};
    \endgroup
}
% Modifies tikz commands \tikz@lib@fit@scan@handle from \pgf\frontendlayer\tikz\libraries\tikzlibraryfit.code.tex line 81 and
% \tikz@calc@anchor from \pgf\frontendlayer\tikz\tikz.code.tex line 5164
% make it so that fit silently ignores nodes that are not defined.
% This is copied with modification from \pgf\frontendlayer\tikz\libraries\tikzlibraryfit.code.tex line 81
\def\sseq@fit@tikz@lib@fit@scan@handle#1{%
  \ifsseq@tempif % this has been set in the following macro to be true if there is a node with the given name. If it's not true, ignore this.
      \iftikz@shapeborder%
        % Ok, fit all four external anchors, if they exist
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{west}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{east}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{north}}%
        \tikz@lib@fit@adjust{\pgfpointanchor{\tikz@shapeborder@name}{south}}%
      \else%
        \tikz@lib@fit@adjust{#1}%
      \fi%
  \fi
  \sseq@tempiftrue
  \tikz@lib@fit@scan%
}

% This is copied with modification from \pgf\frontendlayer\tikz\tikz.code.tex line 5164
\def\sseq@fit@tikz@calc@anchor#1.#2\tikz@stop{%
  \pgfutil@ifundefined{pgf@sh@ns@#1}{\sseq@tempiffalse}{%If the node doesn't exist, don't throw an error but record that we should skip it
    \pgfpointanchor{\tikz@pp@name{#1}}{#2}%
  }%s
}


%%
%% Patch tikz coords
%%

\def\sseq@patchtikzcoords{
    \let\sseq@tikz@scan@one@point@noshift\sseq@tikz@scan@one@point@noshift@active
    \tikzoption{shift}{\sseq@tikzshift{##1}}
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\tikz@to@curve@path\sseq@tikz@to@curve@path
    \let\tikz@@@to@compute@relative\sseq@tikz@@@to@compute@relative

    \let\tikz@grid\sseq@tikz@grid
    \let\tikz@scan@handle@options\sseq@tikz@scan@handle@options
    \let\tikz@@@parse@polar\sseq@tikz@@@parse@polar
}

% Some of the stuff in tikzlibrarycalc will probably be broken, hopefully not too much
\let\sseq@tikz@scan@one@point@noshift\tikz@scan@one@point
\let\sseq@tikz@@@parse@regular@save\tikz@@@parse@regular

\def\sseq@tikz@scan@one@point@noshift@active#1{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@save
    \def\sseq@scanonepoint@cmd{\let\tikz@@@parse@regular\sseq@tikz@@@parse@regular#1}
    \tikz@scan@one@point\sseq@scanonepoint@cmd%
}

% Probably there are more places that shouldn't have shifts inserted.
\def\sseq@tikzshift#1{\tikz@addtransform{\sseq@tikz@scan@one@point@noshift\pgftransformshift#1\relax}}


\def\sseq@tikz@to@curve@path{%
  [every curve to]
  \pgfextra{
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@save % I added this to prevent repeated offsets from screwing us up
    %\let\sseq@tikz@scan@one@point@noshift\tikz@scan@one@point
    \iftikz@to@relative\tikz@to@compute@relative\else\tikz@to@compute\fi
  }
  \tikz@computed@path
  \tikztonodes%
}

\let\sseq@tikz@@@to@compute@relative\tikz@@@to@compute@relative


\patchcmd\sseq@tikz@@@to@compute@relative{%
    \let\tikz@second@point=\tikz@toto
}{%
    \pgf@process{\pgfpointadd{\tikz@toto}{\pgfqpointxy{\sseq@xoffset}{\sseq@yoffset}}}%
    \edef\tikz@toto{\@nx\pgfpoint{\the\pgf@x}{\the\pgf@y}}%
    \let\tikz@second@point=\tikz@toto
}{}{\error}




% \tikz@parse@splitxyz: we should set up an error to make this unreachable?
\let\sseq@tikz@grid\tikz@grid % line 3158
\let\sseq@tikz@scan@handle@options\tikz@scan@handle@options % 4959
\let\sseq@tikz@@@parse@polar\tikz@@@parse@polar % 5063

\def\sseq@tikz@@@parse@regular#1#2#3){%
   % \def\temp{#1(#2,#3)}\show\temp
  \pgfutil@in@,{#3}%
  \ifpgfutil@in@%
    \tikz@parse@splitxyz{#1}{#2}#3,%
  \else%
    \tikz@checkunit{#2}%
    \iftikz@isdimension%
      \tikz@checkunit{#3}%
      \iftikz@isdimension%
        \def\@next{#1{\pgfpointxy{(#2)/1cm+\sseq@xoffset}{(#3)/1cm+\sseq@yoffset}}}%
      \else%
        \def\@next{#1{\pgfpointxy{(#2)/1cm+\sseq@xoffset}{#3+\sseq@yoffset}}}%
      \fi%
    \else%
      \tikz@checkunit{#3}%
      \iftikz@isdimension%
        \def\@next{#1{\pgfpointxy{#2+\sseq@xoffset}{(#3)/1cm+\sseq@yoffset}}}%
      \else%
        \def\@next{#1{\pgfpointxy{#2+\sseq@xoffset}{#3+\sseq@yoffset}}}%
      \fi%
    \fi%
  \fi%
  \@next%
}




%% New shapes and arrows
%% These use lots of keys with spaces so it's convenient to turn off ExplSyntax.

% Stolen from: https://tex.stackexchange.com/a/24621
\pgfqkeys{/pgf}{
    ellipse ratio/.code={\pgfkeyssetvalue{/pgf/ellipse ratio}{#1}},
    ellipse ratio/.initial=1
}
\pgfdeclareshape{newellipse}
{
  \inheritsavedanchors[from=ellipse]
  \inheritanchorborder[from=ellipse]
  \savedanchor\radius{%
    %
    % Caculate ``height radius''
    %
    \pgf@y=.5\ht\pgfnodeparttextbox%
    \advance\pgf@y by.5\dp\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by\pgf@yb%
    %
    % Caculate ``width radius''
    %
    \pgf@x=.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@x by\pgf@xb%
    %
    % Adjust
    %
    \pgfkeysgetvalue{/pgf/ellipse ratio}{\ratioscale}
    \pgfmathsetmacro\widthfactor{sqrt(\ratioscale^2+1)/\ratioscale}
    \pgfmathsetmacro\heightfactor{sqrt(\ratioscale^2+1)}
    \pgf@x=\widthfactor\pgf@x%
    \pgf@y=\heightfactor\pgf@y%
    %
    % Adjust height, if necessary
    %
    \pgfmathsetlength\pgf@yc{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@y<.5\pgf@yc%
      \pgf@y=.5\pgf@yc%
    \fi%
    %
    % Adjust width, if necessary
    %
    \pgfmathsetlength\pgf@xc{\pgfkeysvalueof{/pgf/minimum width}}%
    \ifdim\pgf@x<.5\pgf@xc%
      \pgf@x=.5\pgf@xc%
    \fi%
    %
    % Add outer sep
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@x by\pgf@xb%
    \advance\pgf@y by\pgf@yb%
  }

  \inheritanchor[from=ellipse]{center}
  \inheritanchor[from=ellipse]{mid}
  \inheritanchor[from=ellipse]{base}
  \inheritanchor[from=ellipse]{north}
  \inheritanchor[from=ellipse]{south}
  \inheritanchor[from=ellipse]{west}
  \inheritanchor[from=ellipse]{mid west}
  \inheritanchor[from=ellipse]{base west}
  \inheritanchor[from=ellipse]{north west}
  \inheritanchor[from=ellipse]{south west}
  \inheritanchor[from=ellipse]{east}
  \inheritanchor[from=ellipse]{mid east}
  \inheritanchor[from=ellipse]{base east}
  \inheritanchor[from=ellipse]{north east}
  \inheritanchor[from=ellipse]{south east}

  \inheritbackgroundpath[from=ellipse]
}

%%
%%
%% n concentric circles
%%

\tikzset{circlen/.code={\def\circlen@n{#1}\pgfkeysalso{shape=circlen@shape}}}
\pgfdeclareshape{circlen@shape}
{
  \savedanchor\centerpoint{%
    \pgf@x=.5\wd\pgfnodeparttextbox%
    \pgf@y=.5\ht\pgfnodeparttextbox%
    \advance\pgf@y by-.5\dp\pgfnodeparttextbox%
  }

  \saveddimen\radius{%
    %
    % Caculate ``height radius''
    %
    \pgf@ya=.5\ht\pgfnodeparttextbox%
    \advance\pgf@ya by.5\dp\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@ya by\pgf@yb%
    %
    % Caculate ``width radius''
    %
    \pgf@xa=.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@xa by\pgf@xb%
    %
    % Calculate length of radius vector:
    %
    \pgf@process{\pgfpointnormalised{\pgfqpoint{\pgf@xa}{\pgf@ya}}}%
    \ifdim\pgf@x>\pgf@y%
        \c@pgf@counta=\pgf@x%
        \ifnum\c@pgf@counta=\z@%
        \else%
          \divide\c@pgf@counta by 255\relax%
          \pgf@xa=16\pgf@xa\relax%
          \divide\pgf@xa by\c@pgf@counta%
          \pgf@xa=16\pgf@xa\relax%
        \fi%
      \else%
        \c@pgf@counta=\pgf@y%
        \ifnum\c@pgf@counta=\z@%
        \else%
          \divide\c@pgf@counta by 255\relax%
          \pgf@ya=16\pgf@ya\relax%
          \divide\pgf@ya by\c@pgf@counta%
          \pgf@xa=16\pgf@ya\relax%
        \fi%
    \fi%
    \pgf@x=\pgf@xa%
    %
    % If necessary, adjust radius so that the size requirements are
    % met:
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/minimum width}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@x<.5\pgf@xb%
        \pgf@x=.5\pgf@xb%
    \fi%
    \ifdim\pgf@x<.5\pgf@yb%
        \pgf@x=.5\pgf@yb%
    \fi%
    %
    % Now, add larger of outer sepearations.
    %
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgf@x by\pgf@yb%
    \else%
      \advance\pgf@x by\pgf@xb%
    \fi%
    \pgf@xb=2pt
    \multiply\pgf@xb\circlen@n
    \advance\pgf@x\pgf@xb
    \advance\pgf@x-2pt\relax
  }

  %
  % Anchors
  %
  \anchor{center}{\centerpoint}
  \anchor{mid}{\centerpoint\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{base}{\centerpoint\pgf@y=0pt}
  \anchor{north}{\centerpoint\advance\pgf@y by\radius}
  \anchor{south}{\centerpoint\advance\pgf@y by-\radius}
  \anchor{west}{\centerpoint\advance\pgf@x by-\radius}
  \anchor{east}{\centerpoint\advance\pgf@x by\radius}
  \anchor{mid west}{\centerpoint\advance\pgf@x by-\radius\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{mid east}{\centerpoint\advance\pgf@x by\radius\pgfmathsetlength\pgf@y{.5ex}}
  \anchor{base west}{\centerpoint\advance\pgf@x by-\radius\pgf@y=0pt}
  \anchor{base east}{\centerpoint\advance\pgf@x by\radius\pgf@y=0pt}
  \anchor{north west}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by-0.707107\pgf@xa
    \advance\pgf@y by0.707107\pgf@xa
  }
  \anchor{south west}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by-0.707107\pgf@xa
    \advance\pgf@y by-0.707107\pgf@xa
  }
  \anchor{north east}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by0.707107\pgf@xa
    \advance\pgf@y by0.707107\pgf@xa
  }
  \anchor{south east}{
    \centerpoint
    \pgf@xa=\radius
    \advance\pgf@x by0.707107\pgf@xa
    \advance\pgf@y by-0.707107\pgf@xa
  }
  \anchorborder{
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \edef\pgf@marshal{%
      \noexpand\pgfpointborderellipse
      {\noexpand\pgfqpoint{\the\pgf@xa}{\the\pgf@ya}}
      {\noexpand\pgfqpoint{\radius}{\radius}}%
    }%
    \pgf@marshal%
    \pgf@xa=\pgf@x%
    \pgf@ya=\pgf@y%
    \centerpoint%
    \advance\pgf@x by\pgf@xa%
    \advance\pgf@y by\pgf@ya%
  }

  %
  % Background path
  %
  \behindbackgroundpath{
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
    \sseq@tempcount=\@ne
    \loop
    \pgfpathcircle{\centerpoint}{\pgfutil@tempdima}%
    \advance\pgfutil@tempdima-2pt\relax
    \advance\sseq@tempcount\@ne
    \ifnum\sseq@tempcount<\circlen@n \repeat
    \tikz@mode
    \sseq@eval{\noexpand\pgfusepath{
        \iftikz@mode@draw draw,\fi
    }}
  }
  \backgroundpath{%
    \pgfutil@tempdima=\radius%
    \pgfmathsetlength{\pgf@xb}{\pgfkeysvalueof{/pgf/outer xsep}}%
    \pgfmathsetlength{\pgf@yb}{\pgfkeysvalueof{/pgf/outer ysep}}%
    \ifdim\pgf@xb<\pgf@yb%
      \advance\pgfutil@tempdima by-\pgf@yb%
    \else%
      \advance\pgfutil@tempdima by-\pgf@xb%
    \fi%
    \advance\pgfutil@tempdima2pt\relax
    \pgfutil@tempdimb=-2pt\relax
    \multiply\pgfutil@tempdimb\circlen@n
    \advance\pgfutil@tempdima\pgfutil@tempdimb\relax
    \pgfpathcircle{\centerpoint}{\pgfutil@tempdima}
  }
}



% For out of bounds edges:

\pgfdeclarearrow{
    name = ...,
    parameters = { \the\pgfarrowlength\the\pgflinewidth},
    setup code = {
        % The different end values:
        \pgfarrowssetlineend{-\pgfarrowlength}
        \pgfarrowssetbackend{-0.6\pgfarrowlength}
        % The hull
        \pgfarrowshullpoint{-\pgfarrowlength}{0pt}
        \pgfarrowshullpoint{\pgfarrowlength}{0pt}
        % Saves: Only the length:
        \pgfarrowssavethe\pgfarrowlength
        \pgfarrowssavethe\pgflinewidth
    },
    drawing code = {
        \pgfpathcircle{\pgfpoint{-0.7\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.4\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.1\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathclose
        \pgfusepathqfill
    },
    defaults = { length = 0.3cm }
}

